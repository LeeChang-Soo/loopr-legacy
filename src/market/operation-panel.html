<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<!-- <link rel="import" href="../../bower_components/paper-button/paper-button.html"> -->
<dom-module id="operation-panel" fit>
    <template>
        <style is="custom-style" include="iron-flex iron-flex-alignment paper-material-styles"></style>
        <style include="shared-styles">
            :host {
                display: block;
                --paper-tab-content-unselected: {
                    background-color: white;
                    color: var(--app-text-color-light);
                } --paper-tab-ink: transparent;
                /*--paper-tabs-selection-bar-color: transparent;*/
            }

            paper-tab[name="sell"] {
                color: var(--app-red-color);
            }

            paper-tab[name="buy"] {
                color: var(--app-green-color);
            }

            .container {
                @apply --layout-horizontal;
                @apply --layout-justified;
                @apply --layout-start;
                padding: 32px 32px 0;
                /*min-height: 120px;*/
            }

            .seperator {
                margin-top: 30px;
                color: var(--app-text-color-light);
            }

            vaadin-text-field {
                min-width: 210px;
                height: 80px;
            }

            balance-text-field {
                min-width: 210px;
                height: 80px;
            }

            paper-button {
                height: 36px;
                width: 210px;
                margin-top: 22px;
            }

            .sell paper-button {
                background-color: var(--paper-red-500);
                color: white;
            }

            .sell paper-button:hover {
                background-color: var(--paper-red-700);
            }

            .buy paper-button {
                background-color: var(--paper-green-500);
                color: white;
            }

            .buy paper-button:hover {
                background-color: var(--paper-green-700);
            }

            div.balance {
                padding: 0 32px 2px;
                font-size: 12px;
            }

            div.common {
                color: var(--app-primary-color);
            }

            div.error {
                color: var(--google-red-500);
            }

        </style>
        <global-variable key="wallet" value="{{wallet}}"></global-variable>
        <global-variable key="token-price" value="{{priceQuote}}"></global-variable>
        <global-variable key="app-config" value="{{appConfig}}"></global-variable>
        <global-variable key="balances-raw" value="{{balancesRaw}}"></global-variable>
        <global-variable key="settings-lrcFee" value="{{settingsLrcFee}}"></global-variable>
        <global-variable key="settings-relay" value="{{settingsRelay}}"></global-variable>
        <global-variable key="settings-gasPrice" value="{{settingsGasPrice}}"></global-variable>
        <global-variable key="settings-version" value="{{settingsVersion}}"></global-variable>
        <global-variable key="settings-marginSplit" value="{{settingsMarginSplit}}"></global-variable>
        <global-variable key="settings-expireTime" value="{{settingsExpireTime}}"></global-variable>
        <global-variable key="settings-expireTimeUnit" value="{{settingsExpireTimeUnit}}"></global-variable>

        <paper-tabs selected="{{sellOrBuy}}" attr-for-selected="name">
            <paper-tab name="buy">Buy</paper-tab>
            <paper-tab name="sell">Sell</paper-tab>
        </paper-tabs>
        <iron-pages selected="{{sellOrBuy}}" attr-for-selected="name">
            <div name="sell">
                <div class="sell container">
                    <balance-text-field id="sellAmount" label="[[tokens.token]] Quantity" value="{{sellAmount}}"
                                       pattern="[[_numPatten(tokens.precision)]]"
                                       error-message="non-zero number with [[tokens.precision]] precision "  max="[[tokensBalance]]" min="[[tokens.minTradeValue]]">
                        <div slot="suffix">[[tokens.unit]]</div>
                    </balance-text-field>
                    <div class="seperator">&times;</div>
                    <vaadin-text-field label="[[tokenb.token]]/[[tokens.token]] Price" value="{{sellPrice}}"
                                       pattern="[[_numPatten(marketPrecision)]]"
                                       error-message="non-zero number with [[marketPrecision]] precision">
                        <div slot="suffix">[[tokenb.unit]]/[[tokens.unit]]</div>
                    </vaadin-text-field>
                    <div class="seperator">=</div>
                    <balance-text-field disabled label="[[tokenb.token]] Total" value="{{sellTotal}}"
                                       error-message="[[sellTotalError]]">
                        <div slot="suffix">[[tokenb.unit]]</div>
                    </balance-text-field>
                    <div class="seperator">&nbsp;</div>
                    <paper-button on-click="placeSellOrder" id="sellButton">Sell</paper-button>
                </div>
                <div class="balance">
                    <div class="error">
                        <template is="dom-if" if="[[!isEnough(tokenb.minTradeValue,sellTotal)]]">
                            The min trade value of [[tokenb.token]] must be bigger  than [[tokenb.minTradeValue]]  <br>
                        </template>
                            <template is="dom-if" if="[[!isBalanceEnough(sellAmount,tokensBalance,ethBalance,tokens)]]">
                                <template is="dom-if" if="[[isAllowanceEnough(sellAmount,tokensAllowance)]]">
                                [[_showBalanceNonEnough(tokensBalance,tokens,sellFee,sellAmount)]].<br>
                                </template>
                                <template is="dom-if"
                                          if="[[!isAllowanceEnough(sellAmount,tokensAllowance)]]">
                                    [[_showBothNonEnough(tokensBalance,tokensAllowance,tokens,sellAmount,sellFee)]]  <br>
                                </template>
                            </template>
                        <template is="dom-if" if="[[!isEnoughFee(sellFee,lrcBalance,tokens,sellAmount)]]">
                              You have insufficient LRC balance([[lrcBalance]]) to afford LRC fee and sell [[sellAmount]] [[tokens.token]], we will set Margin Split to be 100% if you continue to place order
                        </template>
                    </div>
                    <div class="common">
                        <template is="dom-if"
                                  if="[[isBalanceEnough(sellAmount,tokensBalance,ethBalance,tokens)]]">
                            Your [[tokens.token]] balance is [[tokensBalance]].
                            Your [[tokens.token]] allowance is [[tokensAllowance]].
                            <template is="dom-if" if="[[!isAllowanceEnough(sellAmount,tokensAllowance)]]">
                              <br>  You have insufficient allowance([[tokensAllowance]]). <a
                                    href="/#/approve/[[tokenb.token]]" tabindex="-1"> Improve allowance </a>
                            </template>
                            <br> [[_showAmountInfo(tokenb, sellTotal, priceQuote,settingsLrcFee)]]
                        </template>
                    </div>
                </div>

            </div>
            <!-- ----- -->
            <div name="buy">
                <div class="buy container">
                    <balance-text-field id="buyAmount" label="[[tokens.token]] Quantity" value="{{buyAmount}}"
                                       pattern="[[_numPatten(tokens.precision)]]"
                                       error-message="non-zero number with [[tokens.precision]] precision "  min="[[tokens.minTradeValue]]">
                        <div slot="suffix">[[tokens.unit]]</div>
                    </balance-text-field>
                    <div class="seperator">&times;</div>
                    <vaadin-text-field label="[[tokenb.token]]/[[tokens.token]] Price" value="{{buyPrice}}"
                                       pattern="[[_numPatten(marketPrecision)]]"
                                       error-message="non-zero number with [[marketPrecision]] precision">
                        <div slot="suffix">[[tokenb.unit]]/[[tokens.unit]]</div>
                    </vaadin-text-field>
                    <div class="seperator">=</div>
                    <balance-text-field disabled label="[[tokenb.token]] Total" value="{{buyTotal}}"
                                       error-message="[[buyTotalError]]">
                        <div slot="suffix">[[tokenb.unit]]</div>
                    </balance-text-field>
                    <div class="seperator">&nbsp;</div>
                    <paper-button on-click="placeBuyOrder" id="buyButton">Buy</paper-button>
                </div>
                <div class="balance">
                    <div class="error">
                        <template is="dom-if" if="[[!isEnough(tokenb.minTradeValue,buyTotal)]]">
                            The min trade value of [[tokenb.token]] must be bigger  than [[tokenb.minTradeValue]] <br>
                        </template>
                            <template is="dom-if" if="[[!isBalanceEnough(buyTotal,tokenbBalance,ethBalance,tokenb)]]">
                                <template is="dom-if" if="[[isAllowanceEnough(buyTotal,tokenbAllowance)]]">
                                    [[_showBalanceNonEnough(tokenbBalance,tokenb,buyFee,buyTotal)]].<br>
                                </template>
                                <template is="dom-if" if="[[!isAllowanceEnough(buyTotal,tokenbAllowance)]]">
                                    [[_showBothNonEnough(tokenbBalance,tokenbAllowance,tokenb,buyTotal,buyFee)]] <br>
                                </template>
                            </template>
                        <template is="dom-if" if="[[!isEnoughFee(buyFee,lrcBalance,tokenb,buyTotal)]]">
                            You have insufficient LRC balance( [[lrcBalance]]) to afford LRC fee and and sell [[buyTotal]] [[tokenb.token]], we will set Margin Split to be 100% if you continue to place order.
                        </template>
                    </div>
                    <div class="common">
                        <template is="dom-if" if="[[isBalanceEnough(buyTotal,tokenbBalance,ethBalance,tokenb)]]">
                            Your [[tokenb.token]] balance is [[tokenbBalance]].
                            Your [[tokenb.token]] allowance is [[tokenbAllowance]].
                            <template is="dom-if" if="[[!isAllowanceEnough(buyTotal,tokenbAllowance)]]">
                               <br> You have insufficient allowance([[tokenbAllowance]]).
                                <a href="/#/approve/[[tokenb.token]]" tabindex="-1"> Improve allowance </a>
                            </template>
                            <br> [[_showAmountInfo(tokenb, buyTotal, priceQuote, settingsLrcFee)]]
                        </template>
                    </div>
                </div>
            </div>
            </div>
        </iron-pages>
    </template>
    <script>


        class OperationPanel extends AppConfigMixin(Polymer.Element) {
            static get is() {
                return 'operation-panel';
            }

            static get properties() {
                return {
                    page: String,
                    subpage: String,
                    market: {
                        type: String,
                        computed: '_computedMarket(page, subpage)'
                    },
                    marketPrecision: {
                        type: Number,
                        computed: '_computePrecision(market,appConfig)'
                    },
                    tokens: {
                        type: Object,
                        computed: '_computeTokenS(market,appConfig)'
                    },
                    tokenb: {
                        type: Object,
                        computed: '_computeTokenB(market,appConfig)'
                    },
                    lrc: {
                        type: Object,
                        computed: '_computelrc(appConfig)'
                    },
                    eth:{
                        type: Object,
                        computed: '_computeeth(appConfig)'
                    },
                    sellOrBuy: {
                        type: String,
                        value: "buy",
                        observer: '_changeTab'
                    },
                    buyAmount: {
                        type: Number,
                        value: 0
                    },
                    buyPrice: {
                        type: Number,
                        value: 0
                    },
                    buyTotal: {
                        type: Number,
                        computed: '_computeBuyTotal(buyAmount, buyPrice,tokenb)'
                    },
                    sellAmount: {
                        type: Number,
                        value: 0
                    },
                    sellPrice: {
                        type: Number,
                        value: 0
                    },
                    sellTotal: {
                        type: Number,
                        computed: '_computeSellTotal(sellAmount, sellPrice,tokenb)',

                    },
                    tokensBalance: Number,
                    tokensAllowance: Number,
                    tokenbBalance: Number,
                    tokenbAllowance: Number,
                    lrcBalance: Number,
                    lrcAllowance: Number,
                    ethBalance:Number,
                    sellFee:{
                        type:Number,
                        computed:'_computeFee(tokenb, sellTotal, priceQuote, settingsLrcFee)'
                    } ,
                    buyFee:{
                        type:Number,
                        computed:'_computeFee(tokenb, buyTotal, priceQuote, settingsLrcFee)'
                    }
                };
            }

            ready() {
                super.ready();
                this.$.buyAmount.focus();
            }

            static get observers() {
                return ['buyButtonState(buyAmount,tokenb,tokens,buyPrice,marketPrecision,buyTotal,tokenbBalance,lrcBalance,buyFee,ethBalance)',
                    'computeTokenBalances(tokens,tokenb,lrc,balancesRaw,eth)',
                    'sellButtonState(sellAmount,tokenb,tokens,sellPrice,marketPrecision,tokensBalance,sellTotal, lrcBalance, sellFee)',
                    'reload(subpage)',
                'computePrice(priceQuote,tokens,tokenb,marketPrecision)'];
            }



            _computedMarket(page, subpage) {
                if (page && "market" === page && subpage) return subpage;
            }

            _changeTab() {
                if ("sell" === this.sellOrBuy) {
                    this.$.sellAmount.focus();
                } else {
                    this.$.buyAmount.focus();
                }
            }


            computePrice(priceQuote,tokens,tokenb,marketPrecision){

                if(priceQuote && tokens && tokenb){

                    const priceS = priceQuote.getPrice(tokens.token.toUpperCase());
                    const priceb = priceQuote.getPrice(tokenb.token.toUpperCase());

                    if(priceb && priceS){

                        this.sellPrice = Number((priceS / priceb).toFixed(marketPrecision));
                        this.buyPrice = Number((priceS / priceb).toFixed(marketPrecision));
                    }
                }

            }

            _computeFee(token, tradeAmount, priceQuote, settingsLrcFe){

                if(token && tradeAmount >= 0 && priceQuote && settingsLrcFe>=0){
                    let selectTokenPrice = priceQuote.getPrice(token.token);
                    let amount = tradeAmount * selectTokenPrice;
                    let fee = amount * settingsLrcFe / 1000;
                    return fee / priceQuote.getPrice("LRC");
                }
            }

            _computePrecision(market, appConfig) {
                if (market && appConfig) {
                    return Number(appConfig.marketMap[market.toUpperCase()].pricePrecision);
                }
            }

            reload(subpage){
                this.sellAmount = 0;
                this.sellPrice = 0;
                this.buyAmount = 0;
                this.buyPrice = 0;
            }

            buyButtonState(buyAmount, tokenb,tokens, buyPrice, marketPrecision, buyTotal, tokenbBalance, lrcBalance, lrcFee,ethBalance) {

                if ((tokenb && tokens && buyAmount && new RegExp(this._numPatten(tokens.precision)).test(buyAmount.toString()) && Number(buyAmount) >= tokens.minTradeValue
                        && buyPrice && new RegExp(this._numPatten(marketPrecision)).test(buyPrice.toString())
                        && buyTotal && Number(buyTotal)>=tokenb.minTradeValue && tokenbBalance  && lrcBalance>=0 && lrcFee>=0)
                    && ((tokenb.token.toUpperCase() === 'WETH' && ethBalance>=0  && buyTotal < (tokenbBalance + ethBalance)) || (tokenb.token.toUpperCase() !== 'WETH' && buyTotal < tokenbBalance))) {
                    this.$.buyButton.disabled = false;
                    this.$.buyButton.style.backgroundColor = 'var(--paper-green-500)';
                } else {
                    this.$.buyButton.disabled = true;
                    this.$.buyButton.style.backgroundColor = 'var(--paper-grey-500)';
                }
            }

            sellButtonState(sellAmount, tokenb, tokens, sellPrice, marketPrecision, tokensBalance, sellTotal, lrcBalance, lrcFee) {

                if (tokens && sellAmount && new RegExp(this._numPatten(tokens.precision)).test(sellAmount.toString()) && Number(sellAmount) >= tokens.minTradeValue
                        && marketPrecision && sellPrice && new RegExp(this._numPatten(marketPrecision)).test(sellPrice.toString())
                        && tokensBalance && Number(tokensBalance) && sellTotal && sellTotal >= tokenb.minTradeValue && lrcBalance >=0 && lrcFee >=0  &&  Number(sellAmount) <= tokensBalance) {
                    this.$.sellButton.disabled = false;
                    this.$.sellButton.style.backgroundColor = 'var(--paper-red-500)';
                } else {
                    this.$.sellButton.disabled = true;
                    this.$.sellButton.style.backgroundColor = 'var(--paper-grey-500)';
                }

            }

            _computeTokenS(market, appConfig) {
                if (market && appConfig) {
                    const tokenPair = market.split('-');
                    const tokenx = tokenPair[0];
                    const token =  _.find(appConfig.tokens, {token: tokenx});
                    token.token = token.token.toUpperCase();
                    return token;
                }
            }

            _computeTokenB(market, appConfig) {

                if (market && appConfig) {
                    const tokenPair = market.split('-');
                    const tokenx = tokenPair[1];
                    const token =  _.find(appConfig.tokens, {token: tokenx});
                    token.token = token.token.toUpperCase();
                    return token;
                }
            }

            _computelrc(appConfig) {
                if (appConfig) {
                    return _.find(appConfig.tokens, {token: "LRC"});
                }
            }

            _computeeth(appConfig){
                if (appConfig) {
                    return _.find(appConfig.tokens, {token: "ETH"});
                }
            }

            _numPatten(precision) {
                if(precision){
                    return "^[1-9]\\d*(\\.\\d{1," + precision + "})?$|^0\\.(\\d{1," + (precision - 1) + "})?[1-9]$";
                }
            }

            _computeBuyTotal(amount, price, tokenb) {
                if (amount && price && Number(price) > 0 && tokenb) {
                    return Math.ceil((amount * price) * Number('1e' + tokenb.precision)) / Number('1e' + tokenb.precision);
                }
            }

            _computeSellTotal(amount, price, tokenb) {
                if (amount && price && Number(price) > 0 && tokenb) {
                    return Math.floor((amount * price) * Number('1e' + tokenb.precision)) / Number('1e' + tokenb.precision);
                }
            }


            async placeBuyOrder() {

                try {
                    if (!this.wallet) {

                        const detail = {
                            text: 'Set Wallet First!',
                            category: 'warning',
                            duration: 5000,
                            link: '/#/wallet',
                            linkText: 'Go to set Wallet'
                        };

                        this.dispatchEvent(new CustomEvent('notification', {
                            bubbles: true,
                            composed: true,
                            detail: detail
                        }));

                        return;
                    }
                    if (!this.appConfig || !this.settingsMarginSplit || !this.settingsLrcFee || !this.settingsExpireTime || !this.settingsExpireTimeUnit) {
                        return;
                    }

                    const whiteList = _.map(this.appConfig.whiteList,add => add.toLowerCase());
                    if (whiteList && whiteList.indexOf(this.wallet.address.toLocaleLowerCase()) < 0) {
                        const detail = {
                            text: 'Your address is not in white list, could not submit order',
                            category: "warning",
                            duration: 5000
                        };
                        this.dispatchEvent(new CustomEvent('notification', {
                            bubbles: true,
                            composed: true,
                            detail: detail
                        }));
                        return;
                    }

                    let data = {};
                    const detail = {};
                    const raws = [];
                    const gasLimit = '0x' + Number(this.appConfig.defaultGasLimit).toString(16) || '0x14820';
                    const gasPrice = '0x' + (Number(this.settingsGasPrice) * 1e9).toString(16);
                    let currentVersion = this.settingsVersion;
                    const spender = this.appConfig.delegateAddress;
                    data.protocol = this.appConfig.contractVersionMap[currentVersion].address;
                    data.owner = this.wallet.address;
                    data.tokenS = this.tokenb.address;
                    data.tokenB = this.tokens.address;
                    data.amountS = '0x' +new  BigNumber(new BigNumber(this.buyAmount.toString()).times(this.buyPrice.toString()).times('1e' + this.tokenb.digits).toFixed(0)).toString(16);
                    data.amountB = '0x' + new BigNumber(this.buyAmount.toString()).times('1e' + this.tokens.digits).toString(16);
                    data.timestamp = Number((new Date().getTime() / 1000).toFixed(0));
                    let ttl = this.appConfig.defaultExpireTime * 24 * 3600;
                    if (this.settingsExpireTimeUnit === "Day") {
                        ttl = this.settingsExpireTime * 24 * 3600;
                    } else if (this.settingsExpireTimeUnit === "Hour") {
                        ttl = this.settingsExpireTime * 3600;
                    } else if (this.settingsExpireTimeUnit === "Minute") {
                        ttl = this.settingsExpireTime * 60;
                    } else if (this.settingsExpireTimeUnit === "Second") {
                        ttl = this.settingsExpireTime;
                    }
                    data.ttl = ttl;
                    data.salt = Math.round(Math.random() * 1e8);
                    if (!this.lrc) {
                        const detail = {
                            text: 'Can\'t get LRC Config',
                            category: "warning",
                            duration: 5000
                        };
                        this.dispatchEvent(new CustomEvent('notification', {
                            bubbles: true,
                            composed: true,
                            detail: detail
                        }));
                        return;
                    }
                    data.lrcFee = this.isEnoughFee(this.buyFee, this.lrcBalance,this.tokenb,this.buyTotal) ? '0x' + new BigNumber(this._showAmount(this.buyFee).toString()).times('1e' + this.lrc.digits).toString(16) : '0x0';
                    data.buyNoMoreThanAmountB = true;
                    data.marginSplitPercentage = Number(data.lrcFee) !==0 ? Number(this.settingsMarginSplit) : 100;
                    detail.order = {
                        raw: JSON.stringify(data),
                        subTitle: "Place an order",
                        description:"Buy "+ Number(this.buyAmount)+" "+ this.tokens.token.toUpperCase()+" with "+ Number(this.buyTotal) +" "+ this.tokenb.token.toUpperCase()
                    };

                    if(this.tokenb.token.toUpperCase() === 'WETH' && Number(this.buyAmount) * this.buyPrice > this.tokenbBalance && Number(this.buyAmount) * this.buyPrice < this.tokenbBalance + this.ethBalance) {

                        const convertTx = {};
                        const WETHConfig = this.appConfig.tokenMap['WETH'];
                        convertTx.data = '0xd0e30db0';
                        convertTx.gasPrice = gasPrice;
                        convertTx.gasLimit = gasLimit;
                        convertTx.to = WETHConfig.address;
                        const value = Number(this.buyAmount) * this.buyPrice - this.tokenbBalance ;
                        convertTx.value = '0x' + new BigNumber('1e' + WETHConfig.digits).times(value.toString(10)).toString(16);
                        const subTitle = 'Convert ETH to  WETH';
                        const description = 'Convert ' + Math.floor((Number(this.buyAmount) * this.buyPrice - this.tokenbBalance) * Number('1e'+this.eth.precision))/ Number('1e'+this.eth.precision) + ' ETH to WETH with gas is ' + Number(convertTx.gasLimit) + ' and gasPrice  is ' + Number(convertTx.gasPrice) / 1e9 + 'Gwei';
                        raws.push({
                            "raw": JSON.stringify(convertTx),
                            "subTitle": subTitle,
                            "description": description
                        });
                    }
                    const relay = new Relay(this.settingsRelay+"/rpc");
                    const response =  await relay.getEstimatedAllocatedAllowance(this.wallet.address, this.tokenb.token.toUpperCase());
                    const balances = _.keyBy(this.balancesRaw.result.tokens, 'token');
                    const allowance = balances[this.tokenb.token.toUpperCase()].allowance ? new BigNumber((balances[this.tokenb.token.toUpperCase()].allowance).toString()) : new BigNumber(0);

                    if (this.tokenb.token.toUpperCase() === 'LRC') {
                        const require = new BigNumber(data.amountS).plus(data.lrcFee).plus(response.result) ;
                        if (require.gt(allowance)) {
                            const amount = new BigNumber('9223372036854775806').times('1e'+this.tokenb.digits);
                            const tx = {};
                            tx.gasPrice = gasPrice;
                            tx.gasLimit = gasLimit;
                            tx.to = this.tokenb.address;
                            tx.value = '0x0';

                            if (allowance.equals(0)) {
                                tx.data = signer.generateApproveData(spender, '0x' + amount.toString(16));
                                raws.push({"raw": JSON.stringify(tx),
                                    "subTitle": "New Authorization Of "+this.tokenb.token.toUpperCase(),
                                    "description":"Set allowance to " + amount.div(Number('1e'+this.tokenb.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                });
                            } else {
                                tx.data = signer.generateApproveData(spender, '0x0');
                                const cancelRaw = JSON.stringify(tx);
                                tx.data = signer.generateApproveData(spender, '0x' + amount.toString(16));

                                raws.push({
                                    "raw": cancelRaw,
                                    "subTitle": "Cancel Older Authorization Of " + this.tokenb.token.toUpperCase(),
                                    "description": "Set allowance to 0 first in order to set Allowance to "+ amount.div(Number('1e'+this.tokenb.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                }, {"raw": JSON.stringify(tx),
                                    "subTitle": "New Authorization Of "+this.tokenb.token.toUpperCase(),
                                    "description":"Set allowance to " + amount.div(Number('1e'+this.tokenb.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                });
                            }
                        }
                    } else {
                        const require = new BigNumber(data.amountS).plus(response.result) ;
                        if (require.gt(allowance)) {
                            const amount = new BigNumber('9223372036854775806').times('1e'+this.tokenb.digits);
                            const tx = {};
                            tx.gasPrice = gasPrice;
                            tx.gasLimit = gasLimit;
                            tx.to = this.tokenb.address;
                            tx.value = '0x0';

                            if (allowance.equals(0) ) {
                                tx.data = signer.generateApproveData(spender, '0x' + amount.toString(16));
                                raws.push({
                                    "raw": JSON.stringify(tx),
                                    "subTitle": "New Authorization Of " + this.tokenb.token.toUpperCase(),
                                    "description":"Set allowance  to " + amount.div(Number('1e'+this.tokenb.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                });
                            } else {
                                tx.data = signer.generateApproveData(spender, '0x0');
                                const cancelRaw = JSON.stringify(tx);
                                tx.data = signer.generateApproveData(spender, '0x' + amount.toString(16));

                                raws.push({
                                    "raw": cancelRaw,
                                    "subTitle": "Cancel Older Authorization Of " + this.tokenb.token.toUpperCase(),
                                    "description": "Set allowance to 0 first in order to set Allowance to "+ amount.div(Number('1e'+this.tokenb.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                }, {
                                    "raw": JSON.stringify(tx),
                                    "subTitle": "New Authorization Of " + this.tokenb.token.toUpperCase(),
                                    "description":"Set allowance to " + amount.div(Number('1e'+this.tokenb.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                });
                            }
                        }

                        const lrcResponse =  await relay.getEstimatedAllocatedAllowance(this.wallet.address, 'LRC');
                        const lrcRequest = new BigNumber(data.lrcFee).plus(lrcResponse.result);
                        if (lrcRequest.gt(new BigNumber(this.lrcAllowance.toString()).times('1e' + this.lrc.digits))) {
                            const lrcAmount = new BigNumber('9223372036854775806').times('1e'+this.lrc.digits);
                            const tx = {};
                            tx.gasPrice = gasPrice;
                            tx.gasLimit = gasLimit;
                            tx.to = this.lrc.address;
                            tx.value = '0x0';

                            if (this.lrcAllowance === 0) {
                                tx.data = signer.generateApproveData(spender, '0x' + lrcAmount.toString(16));
                                raws.push({"raw": JSON.stringify(tx), "subTitle": " New Authorization Of LRC ",
                                    "description":"Improve LRC Allowance to " + lrcAmount.div(Number('1e'+this.lrc.digits)) +" to pay the order fee"+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."});
                            } else {
                                tx.data = signer.generateApproveData(spender, '0x0');
                                const cancelRaw = JSON.stringify(tx);
                                tx.data = signer.generateApproveData(spender, '0x' + lrcAmount.toString(16));

                                raws.push({
                                    "raw": cancelRaw,
                                    "subTitle": "Cancel Older Authorization Of LRC",
                                    "description":"Set LRC allowance to 0 in order to improve it to "+lrcAmount.div(Number('1e'+this.lrc.digits)) +" to pay the order fee with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                }, {"raw": JSON.stringify(tx), "subTitle": "New Authorization Of LRC",
                                    "description":"Improve LRC Allowance to " +lrcAmount.div(Number('1e'+this.lrc.digits)) +" to pay the order fee"+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                });
                            }

                        }
                    }
                    const ETHBalance = balances['ETH'] ? balances['ETH'].balance : 0;
                    if (ETHBalance < raws.length * (Number(gasLimit) * Number(gasPrice))) {
                        const errorDetail = {
                            text: 'You has insufficient ETH balance for gasLimit * gasPrice',
                            category: "warning",
                            duration: 8000
                        };
                        this.dispatchEvent(new CustomEvent('notification', {
                            bubbles: true,
                            composed: true,
                            detail: errorDetail
                        }));
                        return;
                    }
                    detail.raws = raws;
                    this.dispatchEvent(new CustomEvent('placeorder', {
                        bubbles: true,
                        composed: true,
                        detail: detail
                    }));
                } catch (e) {
                console.log(e);
                    const detail = {
                        text: e.message,
                        category: "error",
                        duration: 5000
                    };
                    this.dispatchEvent(new CustomEvent('notification', {
                        bubbles: true,
                        composed: true,
                        detail
                    }));
                }
            }

            async placeSellOrder() {

                try {
                    if (!this.wallet) {
                        const noWalletDetail = {
                            text: 'Set Wallet First!',
                            category: "warning",
                            duration: 5000,
                            link: '/#/wallet',
                            linkText: 'Go to set Wallet'
                        };
                        this.dispatchEvent(new CustomEvent('notification', {
                            bubbles: true,
                            composed: true,
                            detail: noWalletDetail
                        }));

                        return
                    }
                    if (!this.appConfig || !this.settingsMarginSplit || !this.settingsLrcFee || !this.settingsExpireTime || !this.settingsExpireTimeUnit) {
                        return;
                    }
                     const whiteList = _.map(this.appConfig.whiteList,add => add.toLowerCase());
                    if (whiteList && whiteList.indexOf(this.wallet.address.toLowerCase()) < 0) {
                        const detail = {
                            text: 'Your address is not in white list, could not submit order',
                            category: "warning",
                            duration: 5000
                        };
                        this.dispatchEvent(new CustomEvent('notification', {
                            bubbles: true,
                            composed: true,
                            detail: detail
                        }));
                        return;
                    }
                    const detail = {};
                    const data = {};
                    const raws = [];
                    const gasLimit = '0x' + Number(this.appConfig.defaultGasLimit).toString(16) || '0x14820';
                    const gasPrice = '0x' + (Number(this.settingsGasPrice) * 1e9).toString(16);
                    let currentVersion = this.settingsVersion;
                    const spender = this.appConfig.delegateAddress;
                    data.protocol = this.appConfig.contractVersionMap[currentVersion].address;
                    data.owner = this.wallet.address;
                    data.tokenS = this.tokens.address;
                    data.tokenB = this.tokenb.address;
                    data.amountS = '0x' + new BigNumber(this.sellAmount.toString()).times('1e' + this.tokens.digits).toString(16);
                    data.amountB = '0x' + new BigNumber(new BigNumber(this.sellAmount.toString()).times(this.sellPrice.toString()).times('1e' + this.tokenb.digits).toFixed(0)).toString(16);
                    data.timestamp = Number((new Date().getTime() / 1000).toFixed(0));
                    let ttl = this.appConfig.defaultExpireTime * 24 * 3600;
                    if (this.settingsExpireTimeUnit === "Day") {
                        ttl = this.settingsExpireTime * 24 * 3600;
                    } else if (this.settingsExpireTimeUnit === "Hour") {
                        ttl = this.settingsExpireTime * 3600;
                    } else if (this.settingsExpireTimeUnit === "Minute") {
                        ttl = this.settingsExpireTime * 60;
                    } else if (this.settingsExpireTimeUnit === "Second") {
                        ttl = this.settingsExpireTime;
                    }
                    data.ttl = ttl;
                    data.salt = Math.round(Math.random() * 1e8);

                    if (!this.lrc) {
                        const detail = {text: 'Can\'t get LRC Config', category: "warning", duration: 5000};
                        this.dispatchEvent(new CustomEvent('notification', {
                            bubbles: true,
                            composed: true,
                            detail: detail
                        }));
                        return;
                    }
                    data.lrcFee = this.isEnoughFee(this.sellFee, this.lrcBalance,this.tokens,this.sellAmount) ? '0x' + new BigNumber(this._showAmount(this.sellFee).toString()).times('1e' + this.lrc.digits).toString(16) : '0x0';
                    data.buyNoMoreThanAmountB = false;
                    data.marginSplitPercentage = Number(data.lrcFee) !==0 ? Number(this.settingsMarginSplit) : 100;
                    detail.order = {
                        raw: JSON.stringify(data),
                        subTitle: "Place an order",
                        description:"Sell "+ Number(this.sellAmount) +" "+ this.tokens.token.toUpperCase()+"  to get "+ Number(this.sellTotal) +" "+ this.tokenb.token.toUpperCase()
                    };
                    const balances = _.keyBy(this.balancesRaw.result.tokens, 'token');
                    const allowance = balances[this.tokens.token.toUpperCase()].allowance ? new BigNumber((balances[this.tokens.token.toUpperCase()].allowance).toString()) : new BigNumber(0);
                    const relay = new Relay(this.settingsRelay+"/rpc");
                    const response = await relay.getEstimatedAllocatedAllowance(this.wallet.address, this.tokens.token.toUpperCase());

                    if (this.tokens.token.toUpperCase() === 'LRC') {
                        const require = new BigNumber(data.amountS).plus(data.lrcFee).plus(response.result) ;
                        if (require .gt(allowance) ) {
                            const amount = new BigNumber('9223372036854775806').times('1e'+this.tokens.digits);
                            const tx = {};
                            tx.gasPrice = gasPrice;
                            tx.gasLimit = gasLimit;
                            tx.to = this.tokens.address;
                            tx.value = '0x0';

                            if (allowance.equals(0)) {
                                tx.data = signer.generateApproveData(spender, '0x' + amount.toString(16));
                                raws.push({
                                    "raw": JSON.stringify(tx),
                                    "subTitle": "New Authorization Of " + this.tokens.token.toUpperCase(),
                                    "description":"Set allowance  to " +amount.div(Number('1e'+this.tokens.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                });
                            } else {
                                tx.data = signer.generateApproveData(spender, '0x0');
                                const cancelRaw = JSON.stringify(tx);
                                tx.data = signer.generateApproveData(spender, '0x' + amount.toString(16));
                                raws.push({
                                    "raw": cancelRaw,
                                    "subTitle": "Cancel Older Authorization Of " + this.tokens.token.toUpperCase(),
                                    "description": "Set allowance  to 0 first in order to set Allowance to "+ amount.div(Number('1e'+this.tokens.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                }, {
                                    "raw": JSON.stringify(tx),
                                    "subTitle": "New Authorization Of " + this.tokens.token.toUpperCase(),
                                    "description": "Improve allowance  to " + amount.div(Number('1e'+this.tokens.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                });
                            }
                        }

                    } else {
                        const require = new BigNumber(data.amountS).plus(response.result) ;

                        if (require.gt(allowance) ) {
                            const amount = new BigNumber('9223372036854775806').times('1e'+this.tokens.digits);
                            const tx = {};
                            tx.gasPrice = gasPrice;
                            tx.gasLimit = gasLimit;
                            tx.to = this.tokens.address;
                            tx.value = '0x0';

                            if (allowance.equals(0)) {
                                tx.data = signer.generateApproveData(spender, '0x' + amount.toString(16));
                                raws.push({
                                    "raw": JSON.stringify(tx),
                                    "subTitle": "New Authorization Of " + this.tokens.token.toUpperCase(),
                                    "description":"Set allowance for  to " + amount.div(Number('1e'+this.tokens.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                });
                            } else {
                                tx.data = signer.generateApproveData(spender, '0x0');
                                const cancelRaw = JSON.stringify(tx);
                                tx.data = signer.generateApproveData(spender, '0x' + amount.toString(16));
                                raws.push({
                                    "raw": cancelRaw,
                                    "subTitle": "Cancel Older Authorization Of " + this.tokens.token.toUpperCase(),
                                    "description":"Set allowance  to 0 first in order to set Allowance to "+ amount.div(Number('1e'+this.tokens.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                }, {
                                    "raw": JSON.stringify(tx),
                                    "subTitle": "New Authorization Of " + this.tokens.token.toUpperCase(),
                                    "description":"Improve allowance to " + amount.div(Number('1e'+this.tokens.digits))+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                });

                            }
                        }

                        const lrcResponse = await relay.getEstimatedAllocatedAllowance(this.wallet.address, 'LRC');
                        const lrcRequest = new BigNumber(data.lrcFee).plus(lrcResponse.result);

                        if (lrcRequest.gt(new BigNumber(this.lrcAllowance.toString()).times('1e' + this.lrc.digits)) ) {
                            const lrcAmount = new BigNumber('9223372036854775806').times('1e'+this.lrc.digits);

                            const tx = {};
                            tx.gasPrice = gasPrice;
                            tx.gasLimit = gasLimit;
                            tx.to = this.lrc.address;
                            tx.value = '0x0';

                            if (this.lrcAllowance === 0) {
                                tx.data = signer.generateApproveData(spender, '0x' + lrcAmount.toString(16));
                                raws.push({"raw": JSON.stringify(tx),
                                    "subTitle": " New Authorization Of LRC ",
                                    "description":"Improve LRC Allowance to " +lrcAmount.div(Number('1e'+this.lrc.digits)) +" to pay the order fee"+" with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."});
                            } else {
                                tx.data = signer.generateApproveData(spender, '0x0');
                                const cancelRaw = JSON.stringify(tx);
                                tx.data = signer.generateApproveData(spender, '0x' + lrcAmount.toString(16));

                                raws.push({
                                    "raw": cancelRaw,
                                    "subTitle": "Cancel Older Authorization Of LRC",
                                    "description":"Set LRC allowance to 0 in order to improve it to "+lrcAmount.div(Number('1e'+this.lrc.digits)) +" to pay the order fee with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."
                                }, {"raw": JSON.stringify(tx), "subTitle": "New Authorization Of LRC",
                                    "description":"Improve LRC Allowance to " +lrcAmount.div(Number('1e'+this.lrc.digits)) +" to pay the order fee with gas is "+Number(gasLimit)+ " and gasPrice is " + Number(gasPrice)/1e9 + "Gwei."});
                            }
                        }
                    }


                    const ETHBalance = balances['ETH'] ? balances['ETH'].balance : 0;
                    if (ETHBalance < raws.length * (Number(gasLimit) * Number(gasPrice))) {
                        const errorDetail = {
                            text: 'You has insufficient ETH balance for gasLimit * gasPrice',
                            category: "warning",
                            duration: 8000
                        };
                        this.dispatchEvent(new CustomEvent('notification', {
                            bubbles: true,
                            composed: true,
                            detail: errorDetail
                        }));
                        return;
                    }
                    detail.raws = raws;
                    this.dispatchEvent(new CustomEvent('placeorder', {
                        bubbles: true,
                        composed: true,
                        detail: detail
                    }));


                } catch (e) {
                    console.log(e);
                    const detail = {text: e.message, category: "error", duration: 5000};

                    this.dispatchEvent(new CustomEvent('notification', {
                        bubbles: true,
                        composed: true,
                        detail
                    }));
                }
            }

            isAllowanceWarn(allowance, token) {
                if (allowance && token) {
                    return allowance < token.allowanceWarn / Number('1e' + token.digits);
                }
                return false;
            }

            nonEnough(amount, balance, allowance, token, lrcFee) {

                if (balance >= 0 && allowance >= 0 && Number(amount) >= 0 && token) {
                    return (lrcFee>=0 && token.token.toUpperCase() === 'LRC') ?
                        Number(amount) + lrcFee > balance || Number(amount) + lrcFee > allowance :
                        Number(amount) > balance || Number(amount) > allowance
                }
                return false;
            }


            isEnough(require, left) {

                if (left >= 0 && Number(require) >= 0) {
                    return left >= Number(require)
                }
                return true;
            }

            isEnoughFee(lrcFee, lrcBalance, token, amount) {

                if (lrcFee >= 0 && lrcBalance >= 0 && token && amount >= 0) {
                    return token.token.toUpperCase() === "LRC" ? Number(amount) + lrcFee <= lrcBalance: lrcFee <= lrcBalance;
                }
                return true
            }

            isBalanceEnough(require, left,ethBalance,token) {
                if (left >= 0 && Number(require) >= 0 && token && ethBalance>=0 ) {
                    return  token.token.toUpperCase() === 'WETH' ? Number(left) + ethBalance >Number(require): Number(left) >= Number(require)
                }
                return true
            }

            isAllowanceEnough(require,left){
               return this.isEnough(require,left);
            }

            computeTokenBalances(tokens, tokenb, lrc, rawBalances,eth) {

                if (rawBalances) {
                    const balances = _.keyBy(rawBalances.result.tokens, 'token');

                    if(eth){
                        this.ethBalance = balances['ETH'] ? Number(new BigNumber((balances['ETH'].balance).toString()).dividedBy(1e18).toFixed(eth ? eth.precision : 6)) : 0;
                    }

                    if (tokens) {
                        const balance = balances[tokens.token.toUpperCase()] ? new BigNumber((balances[tokens.token.toUpperCase()].balance).toString()) : 0;
                        const allowance = balances[tokens.token.toUpperCase()] ? new BigNumber((balances[tokens.token.toUpperCase()].allowance).toString()) : 0;
                        this.tokensBalance = Number(balance.dividedBy('1e' + tokens.digits).toFixed(tokens.precision));
                        this.tokensAllowance = Number(allowance.dividedBy('1e' + tokens.digits).toFixed(tokens.precision));

                    }
                    if (tokenb) {
                        const balance = balances[tokenb.token.toUpperCase()] ? new BigNumber((balances[tokenb.token.toUpperCase()].balance).toString()) : 0;
                        const allowance = balances[tokenb.token.toUpperCase()].allowance ? new BigNumber((balances[tokenb.token.toUpperCase()].allowance).toString()) : 0;
                        this.tokenbBalance = Number(balance.dividedBy('1e' + tokenb.digits).toFixed(tokenb.precision));
                        this.tokenbAllowance = Number(allowance.dividedBy('1e' + tokenb.digits).toFixed(tokenb.precision));
                    }

                    if (lrc) {
                        const balance = balances[lrc.token.toUpperCase()] ? new BigNumber((balances[lrc.token.toUpperCase()].balance).toString()) : 0;
                        const allowance = balances[lrc.token.toUpperCase()].allowance ? new BigNumber((balances[lrc.token.toUpperCase()].allowance).toString()) : 0;
                        this.lrcBalance = Number(balance.dividedBy('1e' + lrc.digits).toFixed(lrc.precision));
                        this.lrcAllowance = Number(allowance.dividedBy('1e' + lrc.digits).toFixed(lrc.precision));
                    }

                }
            }

            _showAmount(amount) {
                return Math.floor(amount * 100) / 100;
            }

            _numFormat(amount, digits, precision) {

                if (amount && digits && precision) {
                    return (Number(amount) / Number('1e' + digits)).toFixed(precision)
                }
            }

            _showAmountInfo(selectToken, sellAmount, priceQuote, settingsLrcFee) {
                if (selectToken && sellAmount && priceQuote && Number(sellAmount)>=0 && settingsLrcFee >= 0 ) {
                    let selectTokenPrice = priceQuote.getPrice(selectToken.token);
                    let amount = sellAmount * selectTokenPrice;
                    let fee = amount * settingsLrcFee / 1000;
                    let lrcFee = fee / priceQuote.getPrice("LRC");
                    let  info =  "Estimated order value: " + this._showAmount(amount) + ' ' + priceQuote.currency + ". Estimated LRC fee value: " + this._showAmount(fee) + ' ' + priceQuote.currency
                        + " (" + this._showAmount(amount) + ' * ' + settingsLrcFee + '‰, about ' + this._showAmount(lrcFee) + " LRC). " ;

                    if(this._showAmount(lrcFee) === 0 ){
                        info =  info + "Since lrc fee is 0, we will set margin split to 100%."
                    }
                    return info;
                }
            }

            _showBalanceNonEnough(balance, token, lrcFee, amount) {
                if (token && token.token.toUpperCase() === 'LRC') {
                    return "You have insufficient balance(" + balance + ") to place an order with value(" + amount + ") and lrcFee(" + lrcFee + ") ";
                } else {
                    return "You have insufficient balance(" + balance + ") to place an order with value(" + amount + ")";
                }

            }


            _showBothNonEnough(balance, allowance, token, amount, lrcFee) {

                if (token && token.token.toUpperCase() === 'LRC') {
                    return "You have insufficient balance(" + balance + ") and insufficient allowance(" + allowance + ") to place an order with value(" + amount + ") and lrcFee(" + lrcFee + ") ";
                } else {
                    return "You have insufficient balance(" + balance + ")and insufficient allowance(" + allowance + ") to place an order with value(" + amount + ")";
                }

            }


        }

        window.customElements.define(OperationPanel.is, OperationPanel);
    </script>
</dom-module>